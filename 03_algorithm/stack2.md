# Stack 2



## ê³„ì‚°ê¸°



### ë¬¸ìì—´ ìˆ˜ì‹ ê³„ì‚°ì˜ ì¼ë°˜ì  ë°©ë²•

1. ì¤‘ìœ„ í‘œê¸°ë²•ì˜ ìˆ˜ì‹ì„ í›„ìœ„ í‘œê¸°ë²•ìœ¼ë¡œ ë³€ê²½ (ìŠ¤íƒ ì´ìš©)
   1. ì¤‘ìœ„ í‘œê¸°ë²• : ì—°ì‚°ìë¥¼ í”¼ì—°ì‚°ìì˜ ê°€ìš´ë° í‘œê¸°í•˜ëŠ” ë°©ë²•
      1. A+B
   2. í›„ìœ„ í‘œê¸°ë²• :  ì—°ì‚°ìë¥¼ í”¼ì—°ì‚°ìì˜ ë’¤ì— í‘œê¸°í•˜ëŠ” ë°©ë²• 
      1. AB+
2. í›„ìœ„ í‘œê¸°ë²•ì˜ ìˆ˜ì‹ì„ ìŠ¤íƒì„ ì´ìš©í•˜ì—¬ ê³„ì‚°í•œë‹¤.



### ì¤‘ìœ„í‘œê¸°ì‹ -> í›„ìœ„í‘œê¸°ì‹ ë³€í™˜ë°©ë²•

#### 1

1. ìˆ˜ì‹ì˜ ê° ì—°ì‚°ìì— ëŒ€í•´ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ê´„í˜¸ë¥¼ ì‚¬ìš©í•´ ë‹¤ì‹œ í‘œí˜„
2. ì—°ì‚°ìë¥¼ ê·¸ì— ëŒ€ì‘í•˜ëŠ” ì˜¤ë¥¸ìª½ ê´„í˜¸ ë’¤ë¡œ ì´ë™
3. ê´„í˜¸ ì œê±°



```
A*B-C/D
1. ((A*B)-(C/D))
2. ((AB)*(CD)/)-
3. AB*CD/-
```



#### 2 ìŠ¤íƒ ì´ìš©

##### step1

1. ì…ë ¥ë°›ì€ ì¤‘ìœ„ í‘œê¸°ì‹ì—ì„œ í† í°ì„ ì½ëŠ”ë‹¤
2. í† í°ì´ í”¼ì—°ì‚°ìì´ë©´ í† í°ì„ ì¶œë ¥
3. í† í°ì´ ì—°ì‚°ìì¼ ë•Œ, ì´ í† í°ì´ topì— ì €ì¥ë˜ì–´ ìˆëŠ” ì—°ì‚°ìë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë†’ìœ¼ë©´ push, ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ ìŠ¤íƒ topì˜ ì—°ì‚°ìì˜ ìš°ì„ ìˆœìœ„ê°€ í† í°ì˜ ìš°ì„ ìˆœìœ„ ë³´ë‹¤ ì‘ì„ ë•Œê¹Œì§€ ìŠ¤íƒì—ì„œ popí•œ í›„(ì¶œë ¥) push (ê°’ì´ ì—†ì„ ë•Œì—ëŠ” push)
4. í† í°ì´ ')' ì´ë©´ ìŠ¤íƒ topì— '(' ê°€ ì˜¬ ë•Œê¹Œì§€ ìŠ¤íƒì— pop ìˆ˜í–‰í•˜ê³  ì¶œë ¥
5. ì™¼ìª½ ê´„í˜¸ëŠ” popë§Œ í•˜ê³  ì¶œë ¥í•˜ì§€ ì•ŠëŠ”ë‹¤
6. ì¤‘ìœ„ í‘œê¸°ì‹ì— ë” ì½ì„ ê²ƒì´ ì—†ë‹¤ë©´ ì¤‘ì§€í•˜ê³  ë” ì½ì„ ê²ƒì´ ìˆë‹¤ë©´ 1ë¶€í„° ë‹¤ì‹œ ë°˜ë³µ
7. ìŠ¤íƒì— ë‚¨ì•„ìˆëŠ” ì—°ì‚°ìë¥¼ ëª¨ë‘ popí•˜ì—¬ ì¶œë ¥



##### ìŠ¤íƒ ë°–ì˜ ì™¼ìª½ ê´„í˜¸ëŠ” ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ ë†’ê³ , ìŠ¤íƒ ì•ˆì˜ ì™¼ìª½ ê´„í˜¸ëŠ” ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ ë‚®ë‹¤



##### step2

1. í”¼ì—°ì‚°ìë¥¼ ë§Œë‚˜ë©´ ìŠ¤íƒì— push
2. ,ì—°ì‚°ìë¥¼ ë§Œë‚˜ë©´ í•„ìš”í•œ ë§Œí¼ì˜ í”¼ì—°ì‚°ìë¥¼ ìŠ¤íƒì—ì„œ popí•˜ì—¬ ì—°ì‚°í•˜ê³  ì—°ì‚° ê²°ê³¼ë¥¼ ë‹¤ì‹œ ìŠ¤íƒì— push
3. ìˆ˜ì‹ì´ ëë‚˜ë©´ ë§ˆì§€ë§‰ìœ¼ë¡œ ìŠ¤íƒì„ popí•˜ì—¬ ì¶œë ¥





## ğŸ§¶ë°±íŠ¸ë˜í‚¹

> í•´ë¥¼ ì°¾ëŠ” ë„ì¤‘ì— ë§‰íˆë©´ ë˜ëŒì•„ê°€ì„œ ë‹¤ì‹œ í•´ë¥¼ ì°¾ì•„ ê°€ëŠ” ê¸°ë²•
>
> ìµœì í™”(optimization) ë¬¸ì œì™€ ê²°ì •(decision) ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤
>
> ê²°ì • ë¬¸ì œ: ë¬¸ì œì˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” í•´ê°€ ì¡´ì¬í•˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ yes/no ë‹µí•œë‹¤



### ë°±íŠ¸ë˜í‚¹ê³¼ ê¹Šì´ ìš°ì„  íƒìƒ‰ê³¼ì˜ ì°¨ì´

- ì–´ë–¤ ë…¸ë“œì—ì„œ ì¶œë°œí•˜ëŠ” ê²½ë¡œê°€ í•´ê²°ì±…ìœ¼ë¡œ ì´ì–´ì§ˆ ê²ƒ ê°™ì§€ ì•Šìœ¼ë©´ ë” ì´ìƒ ê·¸ ê²½ë¡œë¥¼ ë”°ë¼ê°€ì§€ ì•Šê³  ì‹œë„ì˜ íšŸìˆ˜ë¥¼ ì¤„ì„ (Prunning ê°€ì§€ì¹˜ê¸°)
- ê¹Šì´ìš°ì„ íƒìƒ‰ì´ ëª¨ë“  ê²½ë¡œë¥¼ ì¶”ì í•˜ëŠ” ë° ë¹„í•´ ë°±íŠ¸ë˜í‚¹ì€ ë¶ˆí•„ìš”í•œ ê²½ë¡œë¥¼ ì¡°ê¸° ì°¨ë‹¨
- ê¹Šì´ìš°ì„ íƒìƒ‰ì€ ê²½ìš°ì˜ ìˆ˜ê°€ ë„ˆë¬´ ë§ë‹¤ (N!)
- ë°±íŠ¸ë˜í‚¹ ì•Œê³ ë¦¬ì¦˜ì€ ì¼ë°˜ì ìœ¼ë¡œ ê²½ìš°ì˜ ìˆ˜ê°€ ì¤„ì–´ë“¤ì§€ë§Œ ìµœì•…ì˜ ê²½ìš°ì—ëŠ” ì§€ìˆ˜ í•¨ìˆ˜ ì‹œê°„(Exponential Time) ìš”í•˜ë¯€ë¡œ ì²˜ë¦¬ ë¶ˆê°€ëŠ¥



##### ë°±íŠ¸ë˜í‚¹ì€ ì•Œê³ ë¦¬ì¦˜ì´ ì•„ë‹Œ ê¸°ë²•, DFS ì™€ ê°™ì´ ì‚¬ìš©í•˜ì—¬ ê²½ìš°ì˜ ìˆ˜ë¥¼ ì¤„ì¸ë‹¤.



### ë°±íŠ¸ë˜í‚¹ ê¸°ë²•

- ë…¸ë“œì˜ ìœ ë§ì„±ì„ ì ê²€í•œ í›„ì— ìœ ë§í•˜ì§€ ì•Šë‹¤ë©´ ë…¸ë“œì˜ ë¶€ëª¨ë¡œ ëŒì•„ê°€ ë‹¤ìŒ ìì‹ ë…¸ë“œë¡œ ê°„ë‹¤
- ì–´ë–¤ ë…¸ë“œë¥¼ ë°©ë¬¸í–ˆì„ ë•Œ ê·¸ ë…¸ë“œë¥¼ í¬í•¨í•œ ê²½ë¡œê°€ í•´ë‹µì´ ë  ìˆ˜ ì—†ë‹¤ë©´ ê·¸ ë…¸ë“œëŠ” ìœ ë§í•˜ì§€ ì•Šë‹¤
- ê°€ì§€ì¹˜ê¸° (pruning) :  ìœ ë§í•˜ì§€ ì•Šì€ ë…¸ë“œê°€ í¬í•¨ë˜ëŠ” ê²½ë¡œëŠ” ë” ì´ìƒ ê³ ë ¤í•˜ì§€ ì•ŠëŠ”ë‹¤.



### ì ˆì°¨

1. ìƒíƒœ ê³µê°„ íŠ¸ë¦¬ì˜ ê¹Šì´ ìš°ì„  ê²€ìƒ‰ì„ ì‹¤ì‹œí•œë‹¤
2. ê° ë…¸ë“œê°€ ìœ ë§í•œì§€ ì ê²€í•œë‹¤ (promising)
3. ìœ ë§í•˜ì§€ ì•Šì€ ë…¸ë“œì´ë©´, ë¶€ëª¨ ë…¸ë“œë¡œ ëŒì•„ê°€ ê²€ìƒ‰ì„ ê³„ì†í•œë‹¤. (pruning)



```
def checknode(v):
	if promising(v):
		if there is a solution at v:
			write the solution
		else:
			for u in each child of v:
				checknode(u)
```



## ë¶€ë¶„ì§‘í•© êµ¬í•˜ê¸°

> ì–´ë–¤ ì§‘í•©ì˜ ê³µì§‘í•©ê³¼ ìê¸° ìì‹ ì„ í¬í•¨í•œ ëª¨ë“  ë¶€ë¶„ì§‘í•© : powerset (2^n)



### ë°±íŠ¸ë˜í‚¹ ê¸°ë²•ìœ¼ë¡œ powerset êµ¬í•˜ê¸°

- nê°œì˜ ì›ì†Œê°€ ë“¤ì–´ìˆëŠ” ì§‘í•©ì˜ 2^n  ë¶€ë¶„ì§‘í•©ì„ ë§Œë“¤ ë•Œ, true/false ê°’ ê°€ì§€ëŠ” í•­ëª©ë“¤ë¡œ êµ¬ì„±ëœ n ê°œì˜ ë°°ì—´ì„ ë§Œë“ ë‹¤.
- ë°°ì—´ì˜ i ë²ˆì§¸ í•­ëª©ì€ i ë²ˆì§¸ ì›ì†Œê°€ ë¶€ë¶„ì§‘í•©ì˜ ê°’ì¸ì§€ ì•„ë‹Œì§€ ë‚˜íƒ€ë‚¸ë‹¤.



```
def backtrack(a, k, input): // k ì¸ë±ìŠ¤, input ëª‡ê°œê¹Œì§€ ë½‘ì„ì§€
	global MAXCANDIDATES
	c = [0] * MAXCANDIDATES
	
	if k == input:
		process_solution(a, k)  // ë‹µì´ë¼ë©´ ì›í•˜ëŠ” ì‘ì—…ì„ í•œë‹¤
	else:
		k += 1
		ncandidates = construct_candidates(a, k, input, c)
		for i in range(ncandidates): // 2
			a[k] = c[i] // True, False
			backtrack(a, k, input)
			
def construct_candidates(a, k, input, c):
	c[0] = True
	c[1] = False
	return 2
	
MAXCANDIDATES = 100
NMAX = 100
a = [0] * NMAX  // ì›ì†Œ ì‚¬ìš© ì—¬ë¶€ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
backtrack(a, 0, 3)  
```



- ì¬ê·€ë¡œ ë¶€ë¶„ì§‘í•© êµ¬í•˜ê¸°

```python
N = 3

arr = [1, 2, 3]  # ìš°ë¦¬ê°€ í™œìš©í•  ë°ì´í„°

sel = [0] * N  # a ë¦¬ìŠ¤íŠ¸ (ë‚´ê°€ í•´ë‹¹ ì›ì†Œë¥¼ ë½‘ì•˜ëŠ”ì§€?)


def power_set(idx):
    if idx == N:
        print(sel, ":", end=' ')
        for i in range(N):
            if sel[i]:
                print(arr[i], end='')
        print()

    else:
        # idx ìë¦¬ì˜ ì›ì†Œë¥¼ ë½‘ê³  (True) ê°„ë‹¤.
        sel[idx] = 1
        power_set(idx+1)

        # idx ìë¦¬ì˜ ì›ì†Œë¥¼ ì•ˆ ë½‘ê³ (False) ê°„ë‹¤.
        sel[idx] = 0
        power_set(idx+1)


power_set(0)
```



## ìˆœì—´ ìƒì„±í•˜ê¸°



### 1 ë‹¨ìˆœí•˜ê²Œ ìˆœì—´ ìƒì„±í•˜ê¸°

- ë™ì¼í•œ ìˆ«ìê°€ í¬í•¨ë˜ì§€ ì•Šì•˜ì„ ë•Œ, ê° ìë¦¬ ìˆ˜ ë³„ë¡œ loop ì´ìš©í•´ êµ¬í˜„

```
for i1 in range(1, 4):
	for i2 in range(1, 4):
		if i1 != i2:
			for i3 in range(1,4):
				if i1 != i2 != i3:
					print(i1, i2, i3)
```



### 2 ë°±íŠ¸ë˜í‚¹ì„ ì´ìš©í•˜ì—¬ ìˆœì—´ êµ¬í•˜ê¸°

```
def backtrack(a, k, input): // sel, idx, ìˆœì—´ì˜ ìˆ˜
	global MAXCANDIDATES
	c = [0] * MAXCANDIDATES
	
	if k == input:
		for i in range(1, k+1):
			print(a[i], end = '')
		print()
	else:
		 k += 1
		 ncandidates = construct_candidates(a, k, input, c)
		 for i in range(ncandidates):
		 	a[k] = c[i]
		 	backtrack(a, k, input)
		 
		 
def construct_cnadidates(a, k, input, c):
	in_perm = [False] * NMAX // visited ê°™ì€
	
	for i in range(1, k):
		in_perm[a[i]] = True // ì´ì œê¹Œì§€ì˜ kë¥¼ Trueë¡œ í‘œì‹œ
		
	ncandidates=0
	for i in range(1, input+1):
		if in_perm[i] == False:
			c[ncandidates] = i
			ncandidates += 1
	return ncandidates
```



```python
arr = [1, 2, 3]
N = 3  # ëª‡ê°œ ê¸¸ì´ì˜ ìˆœì—´ì„ ë§Œë“¤ì§€
sel = [0]*N  # ê²°ê³¼ë“¤ì´ ì €ì¥ë  ë¦¬ìŠ¤íŠ¸
check = [0]*N  # í•´ë‹¹ ì›ì†Œë¥¼ ì´ë¯¸ ì‚¬ìš©í–ˆëŠ”ì§€ ì•ˆ í–ˆëŠ”ì§€ì— ëŒ€í•œ ì²´í¬


# idx ëŠ” ê¹Šì´ë¥¼ ì˜ë¯¸í•˜ê³  ìˆœì—´ì˜ ê¸¸ì´ê°€ ìµœëŒ€ ê¹Šì´ë¥¼ ê²°ì •í•œë‹¤.
def perm(idx):

    # ë‹¤ ë½‘ì•„ì„œ ì •ë¦¬í–ˆë‹¤ë©´
    if idx == N:
        print(sel)
    else:
        for i in range(N):
            if check[i] == 0:  # í•´ë‹¹ ì›ì†Œë¥¼ ì•„ì§ ì“°ì§€ ì•Šì•˜ë‹¤
                sel[idx] = arr[i]  # ê°’ì„ ì¨ë¼
                check[i] = 1  # ì‚¬ìš©ì„ í–ˆë‹¤ëŠ” í‘œì‹œ
                perm(idx+1)
                check[i] = 0  # ë‹¤ìŒ ë°˜ë³µë¬¸ì„ ìœ„í•œ ì›ìƒë³µêµ¬


perm(0)
```





### 3 ë¹„íŠ¸ ì‚¬ìš©í•˜ê¸°

```python
arr = [1, 2, 3]
N = 3
sel = [0]*N  # ë½‘ì€ ê²°ê³¼ë¥¼ ì ìŒ


# ì—¬ê¸°ì„œ ì‚¬ìš©í•˜ëŠ” check ëŠ” 10ì§„ìˆ˜ ì •ìˆ˜
def perm(idx, check):
    if idx == N:
        print(sel)
        return

    for j in range(N):

        # j ë²ˆì§¸ ì›ì†Œë¥¼ í™œìš©ì„ í–ˆë‹¤ë©´ ê·¸ê±¸ ì“°ë©´ ì•ˆ ë˜ì§€
        if check & (1 << j):
            continue

        sel[idx] = arr[j]
        perm(idx+1, check | (1 << j))  # 1íšŒì„± ì‚¬ìš©ì´ë¼ ì›ìƒë³µê·€ê°€ í•„ìš”ì—†ë‹¤.


perm(0, 0)
```





### 4 SWAP

```python
arr = [1, 2, 3]
N = 3


def perm(idx):
    if idx == N:
        print(arr)

    else:
        for i in range(idx, N):  # í˜„ì¬ ìœ„ì¹˜ë¶€í„° N-1 ê¹Œì§€ ìˆœíšŒ

            arr[idx], arr[i] = arr[i], arr[idx]  # ìˆœì„œ ë°”ê¾¸ê¸° 0,0 ë°”ê¿”ë³´ê³  0,1 ë°”ê¿”ë³´ê³  0,2 ë°”ê¿”ë³´ê³ ...ë°˜ë³µ
            perm(idx+1)
            arr[idx], arr[i] = arr[i], arr[idx]  # ë‹¤ìŒ ë°˜ë³µë¬¸ì„ ìœ„í•´í•´ ì›ìƒ ë³µê·€


perm(0)
```





## ë¶„í• ì •ë³µ ì•Œê³ ë¦¬ì¦˜



- ë¶„í•  (Devide) : í•´ê²°í•  ë¬¸ì œë¥¼ ì—¬ëŸ¬ ê°œì˜ ì‘ì€ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆˆë‹¤
- ì •ë³µ(Conquer) : ë‚˜ëˆˆ ì‘ì€ ë¬¸ì œë¥¼ ê°ê° í•´ê²°í•œë‹¤
- í†µí•©(Combine) : í•„ìš”í•˜ë‹¤ë©´ í•´ê²°ëœ í•´ë‹µì„ ëª¨ì€ë‹¤



### ì˜ˆì œ

1. ê±°ë“­ì œê³± O(n)

```
def power(base, exponent):

	if base == 0:
		return 1
	
	result = 1
	for i in range(exponent):
		result *= base
	
	return result
```



- O(logn)

```
def power(base, exp):
	if exp == 0 or base == 0:
		return 1
	
	if exp % 2 == 0:
		newbase = power(base, exponent/2)
		return newbase * newbase
	else:
		newbase = power(base, (exp-1)/2)
		return newbase*newbase*base
```





## í€µì •ë ¬

> ì£¼ì–´ì§„ ë°°ì—´ì„ ë‘ ê°œë¡œ ë¶„í• í•˜ê³  ê°ê°ì„ ì •ë ¬í•œë‹¤.



- í•©ë³‘ì •ë ¬ê³¼ì˜ ì°¨ì´
  - í•©ë³‘ ì •ë ¬ì€ ê·¸ëƒ¥ ë‘ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆˆë‹¤
  - í€µì •ë ¬ì€ ë¶„í•  í•  ë•Œ ê¸°ì¤€ ì•„ì´í…œ ì¤‘ì‹¬ìœ¼ë¡œ ì´ë³´ë‹¤ ì‘ì€ ê²ƒì€ ì™¼ìª½, í° ê²ƒì€ ì˜¤ë¥¸ìª½ì— ìœ„ì¹˜ì‹œí‚¨ë‹¤ (ì›ë³¸ì„ ìˆ˜ì •í•œë‹¤)
  - ë¶„í• í•˜ë©´ì„œ ì •ë ¬ë˜ì–´ ê°„ë‹¤.
  - ê° ë¶€ë¶„ ì •ë ¬ì´ ëë‚œ í›„ í•©ë³‘ ì •ë ¬ì€ í•©ë³‘ì´ë¼ëŠ” í›„ì²˜ë¦¬ ì‘ì—…ì´ í•„ìš”í•˜ë‹¤.



```python
def quick_sort(a, begin, end):
	if begin < end:
		p = partition(a, begin, end) # pivot ê¸°ì¤€ìœ¼ë¡œ ì¢Œìš°ë¡œ ë‚˜ëˆ„ì–´ ë¶„í• 
		quick_sort(a, begin, p-1)
		quick_sort(a, p+1, end)
```



- í˜¸ì–´ íŒŒí‹°ì…˜
  - pivot ì˜ ìœ„ì¹˜ì— ë”°ë¼ì„œ ê·¸ë¦¼ì´ ë‹¬ë¼ì§„ë‹¤.

```python
def partition(a, begin, end):
	pivot = (begin+end)//2
	L = begin
	R = end
	while L < R:
		while(a[L]<a[pivot] and L<R) : L += 1  # Lì€ pivot ê°’ ê³¼ ê°™ê±°ë‚˜ í´ë•Œ ë©ˆì¶˜ë‹¤
		
		while(a[R]>=a[pivot] and L<R) : R -= 1  # Rì€ pivot ê°’ ë³´ë‹¤ ì‘ì„ ë•Œ ë©ˆì¶˜ë‹¤
		
		if L < R:
			if L == pivot:
				pivot = R  
                # ìƒˆë¡œìš´ í”¼ë²— (Lì´ ì¤‘ê°„ì´ë¼ëŠ”ê±´ ì™¼ìª½ì´ ë‹¤ pivotë³´ë‹¤ ì‘ë‹¤ëŠ” ëœ»ì´ê³ )
                # í”¼ë²— ì´ìƒ ~ R ì‚¬ì´ì˜ ìš”ì†Œë¥¼ ì‚´í´ë³´ê¸° ìœ„í•´ pivotì„ Rì˜ ìœ„ì¹˜ë¡œ ë¯¼ë‹¤.
			a[L], a[R] = a[R], a[L]
			
	# L==Rì¸ ìƒíƒœ	
	a[pivot], a[R] = a[R], a[pivot]  # í”¼ë´‡ ìœ„ì¹˜ë¥¼ í™•ì •
    # í”¼ë´‡ê³¼ ê°™ì•˜ë‹¤ë©´ ìê¸° ìì‹ ê³¼ ë°”ê¾¸ëŠ” ê²ƒì´ê³ 
    # í”¼ë´‡ê³¼ ë‹¤ë¥¸ ìœ„ì¹˜ì˜€ë‹¤ë©´ í”¼ë´‡ë³´ë‹¤ ì‘ì€ ê°’ì´ê±°ë‚˜ í”¼ë´‡ë³´ë‹¤ í° ê°’ì—ì„œ ë©ˆì·„ì„ ê²ƒì´ê¸° ë•Œë¬¸
	
	return R		
```



### ì‹œê°„ ë³µì¡ë„

- ìµœì•… : O(n^2)
- í‰ê·  : O(nlogn)



![image-20210225013534282](stack2.assets/image-20210225013534282.png)